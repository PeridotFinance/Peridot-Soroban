Technical Architecture for Leveraged Cross-Margin Trading on Soroban (Peridot)
Contract Architecture and Components
Margin Trading Contract: The core of the design is a new Margin Manager smart contract that extends Peridot’s lending system to support up to 5× leverage. This contract manages user margin accounts and positions, enforcing cross-margin mechanics (shared collateral pool) and risk rules. It interacts with other modules but keeps margin logic self-contained:
User Margin Accounts: Each user has a cross-margin account in the contract with a pooled collateral balance. All positions draw from this shared collateral pool
, meaning a user’s total equity backs all their trades. Profits in one position can offset losses in another, but severe losses in one can erode collateral for others
.
Position Management: The margin contract tracks open positions (initially only XLM trades vs a USD stablecoin). It allows multiple long or short positions per user, each tied into the user’s single collateral pool (cross-margin). Positions are not isolated; the contract evaluates risk on the aggregate of a user’s portfolio.
Integration with Lending Pools: The contract reuses Peridot’s existing Soroban lending contracts for borrowing/lending. It does not implement interest logic itself – instead, it calls the lending contracts to deposit collateral and take loans. This ensures compatibility with Peridot’s interest accrual, collateral tracking, and liquidation mechanisms that already exist for standard loans. For example, when a user opens a leveraged long, the margin contract will deposit the user’s collateral into the lending pool and borrow the counter-asset via the lending contract. All assets moved in and out of the margin contract use the standard Soroban token interface (SEP-41 via Stellar Asset Contracts) for safety and interoperability
.
Price Oracle Module: The design relies on the Reflector Oracle network for price feeds. A separate Price Oracle contract (provided by Reflector) is deployed on Soroban and continuously updated with the XLM price (in terms of the USD stablecoin). The margin contract will query this oracle contract for up-to-date prices whenever needed (e.g. to compute health factors or liquidation conditions). The oracle operates off-chain via Reflector nodes, but on-chain it exposes a client interface to fetch the latest price and timestamp.
Liquidation Bot (External): In addition to on-chain logic, a Liquidator Bot service will run off-chain (as part of Peridot’s bots) to monitor positions and execute liquidations when necessary. This serves as a fallback to ensure positions are closed out even if on-chain automated triggers fail or if arbitrage opportunities need external execution. The bot uses the same contract interfaces (calling the liquidate function) and is incentivized by liquidation bonuses.
Separation of Concerns: The architecture cleanly separates responsibilities:
Margin Contract – orchestrates margin trade lifecycle and risk checks.
Lending Contracts – handle asset custody, interest accrual, and basic loan accounting (remains unchanged; margin contract is a client).
Oracle Contract – provides price data; margin contract only reads from it.
Liquidation Bot – off-chain agent to supplement on-chain liquidation triggers.
Token Contracts (SAC) – standard asset contracts (SEP-41) for XLM, USDC, etc., used for all token transfers. The margin contract does not directly use Stellar’s order book (which is not accessible via contracts
); all trading is via external swap operations (described below).
By modularizing in this way, each piece can be upgraded or maintained independently. The margin contract can be designed for upgradability (see Security & Upgradeability below) without altering the underlying lending pools or oracle network.
Contract Interface: Methods and Events
Public Methods: The Margin Manager contract exposes functions for users and liquidators. Key methods include:
deposit_collateral(user: Address, asset: Address, amount: u128) – Deposit collateral into the user’s cross-margin account. Transfers the specified asset (e.g. USD stablecoin) from the user to the contract, after verifying user authorization
. It then calls the corresponding lending pool to supply this collateral (earning interest). Emits a CollateralDeposited event.
withdraw_collateral(user: Address, asset: Address, amount: u128) – Withdraw excess collateral if the user has margin headroom. Ensures that even after withdrawal, the user’s remaining collateral meets all margin requirements. If safe, it withdraws funds from the lending pool and transfers the asset back to the user. Emits CollateralWithdrawn.
open_position(user: Address, side: PositionSide, size: u128, leverage: u128) – Open a new leveraged position. side can be LONG or SHORT. The size represents the total position notional in terms of the quote asset (e.g. USD value of XLM position), and leverage (up to 5×) determines required collateral. Internally, this function will:
Verify the user’s margin account has sufficient equity (or require additional collateral deposit in the same transaction) such that required_initial_margin = size / leverage is covered. This enforces the initial margin (e.g. 20% for 5×)
.
If side=LONG (long XLM): use the user’s collateral to borrow the quote asset (USD) from the lending contract, equal to the difference between position size and user’s own contribution. If leverage is maximum, the user’s contribution = size/leverage. The borrowed amount = size – collateral. If the user provided exactly size/leverage as collateral, the contract borrows the rest. It then temporarily transfers the borrowed USD asset to the user (or a transient escrow) to facilitate the swap (see Transaction Composition below).
If side=SHORT (short XLM): use the user’s collateral (USD) to borrow XLM from the lending pool (the base asset to be shorted). Transfer the borrowed XLM to the user for swapping.
Record a new position entry in the contract’s state (assigned a unique position ID). This record includes the position side, the borrowed amount, and the entry debt and entry asset amounts.
Emit a PositionOpened event with details (user, position ID, side, size, entry price, collateral used, etc).
increase_position(user: Address, position_id: u64, additional_size: u128) – Increase the size of an existing position (leverage up further or add exposure). This is effectively a partial open on the same asset/side. It follows a similar process as open_position: require additional margin or available free collateral, borrow more from the pool, and execute an asset swap to increase the position’s holdings. The position record is updated (e.g. weighted average entry price recalculated).
reduce_position(user: Address, position_id: u64, reduce_size: u128) – Partially close a position (take profit or cut loss on a portion). This will initiate a swap of a portion of the position’s asset back to the other asset and repay that portion of debt. For example, for a long: transfer out a fraction of held XLM to the user to sell for USD, then use the returned USD to repay part of the loan. The position record is updated with a reduced size. Emits PositionReduced.
close_position(user: Address, position_id: u64) – Close the position entirely. The contract will facilitate selling the entire position asset and repaying the debt. After debt repayment, any remaining funds (profits) are returned to the user’s collateral pool. The position is removed from storage. Emits PositionClosed.
liquidate(position_id: u64, liquidator: Address) – Third-party liquidation call for under-margined positions. If the position (or user’s overall account) is below maintenance margin, this function allows a liquidator to repay part or all of the debt in exchange for a corresponding amount of collateral. The contract checks the latest price via the oracle and computes the user’s health factor (see Risk Engine). If health factor < 1 (meaning collateral value no longer covers the required maintenance margin
), liquidation is permitted. The liquidator must pay in the debt asset (e.g. provide USD to repay a long’s loan, or provide XLM to repay a short’s loan). In return, the contract transfers a proportionate amount of the position’s collateral asset to the liquidator, including a bonus (discount). For example, a liquidator repays $X of a defaulted loan and receives $X * 1.05 worth of XLM from the position – a 5% bonus incentive. The position is reduced or closed accordingly, and a PositionLiquidated event is emitted. (This function is permissionless; typically the off-chain bot or any arbitrageur would call it.)
get_health_factor(user: Address) – (View function) Calculate the user’s current health factor given latest prices. Returns the ratio of account collateral value to required collateral (maintenance). Useful for UIs or bots to identify risk.
get_position(position_id: u64) – (View) Fetches details of a position (side, size, debt, collateral allocated, P/L, etc.). Does not change state.
Administrative Methods: (Protected by contract admin) e.g. set_risk_params(new_initial_margin: fixed, new_maintenance_margin: fixed, new_liquidation_bonus: fixed), pause() to halt new positions (for emergencies), and possibly upgrade(new_wasm_hash) to upgrade the contract code if using Soroban’s built-in upgradability. These can only be invoked by an authorized admin account (such as a multisig or DAO governance address). The contract uses Soroban’s authorization framework to restrict these (e.g. storing an admin address in state and calling admin.require_auth() inside these functions).
Events: The contract will emit events for all key actions to facilitate indexing and off-chain monitoring:
CollateralDeposited(user, asset, amount) – on collateral deposit.
CollateralWithdrawn(user, asset, amount) – on collateral withdrawal.
PositionOpened(user, position_id, side, base_amount, quote_amount, entry_price) – when a new long/short is opened. Includes initial amounts borrowed and purchased.
PositionIncreased(user, position_id, added_size, new_total_size, new_entry_price) – on position expansion.
PositionReduced(user, position_id, reduced_size, remaining_size, price) – on partial close.
PositionClosed(user, position_id, exit_price, profit_or_loss) – on full close.
PositionLiquidated(user, position_id, liquidator, amount_repaid, collateral_seized) – when liquidation occurs, logging how much was repaid by the liquidator and how much collateral they received.
All events will include the user’s address and relevant position or asset info. These events enable wallets and UIs to track margin activity in real-time. (The oracle price updates are handled by the Reflector contract and can also be observed via its events, but those are external to this margin contract.)
State Storage Layout
The margin contract’s state is organized to efficiently track user accounts and positions. Soroban contract storage (key–value entries) will be structured as follows:
Global Parameters: Stored in the instance storage (persistent singleton):
InitialMarginRatio (e.g. 20% as a fixed-point number) – the required collateral fraction to open new positions (implies max leverage 5×).
MaintenanceMarginRatio (e.g. 10%) – the minimum collateral ratio to avoid liquidation.
LiquidationBonus (e.g. 5% or 1.05x) – the extra collateral a liquidator receives (penalty to the borrower).
OracleContractID – the Address (contract ID) of the Reflector oracle feed contract for price data.
LendingContractIDs – references to the lending pool contracts for assets involved (e.g. USD stablecoin lending pool, XLM lending pool). These are used to invoke deposit/borrow/repay functions.
AdminAddress – the administrator account allowed to adjust parameters or upgrade the contract.
(Optionally, PositionCounter for generating unique position IDs.)
User Collateral and Account Data: Likely stored in a map keyed by user:
Key: CollateralBalance(user_addr, asset_code) -> Value: amount of that asset held as collateral by the margin contract on behalf of the user. In the initial version, this may be primarily one stablecoin (e.g. USDC) as collateral. This balance reflects funds the contract has deposited into the lending pool for the user. The contract can derive the up-to-date value (including any earned interest) by querying the lending contract or using an interest index. Collateral can also be XLM or other assets if multi-asset collateral is later allowed, so the key includes asset identifier.
Key: PositionsByUser(user_addr) -> Value: list (or set) of position IDs currently open for that user. This provides quick lookup of a user’s positions.
Key: TotalDebt(user_addr, asset_code) -> Value: total amount of a given asset the user owes (borrowed) across all positions. (This might be derived from summing positions, but keeping it could simplify aggregate health calculations. Alternatively, each position stores its own debt and we sum on the fly.)
Position Records: Each open position is stored in a map by PositionID:
Key: Position(position_id) -> Value: a struct with fields:
owner: Address – the user who owns the position.
side: PositionSide – LONG or SHORT.
base_asset: Asset – e.g. XLM (the asset being longed or shorted).
quote_asset: Asset – e.g. USD stablecoin (the counter asset).
base_amount: i128 – how much of the base asset the contract currently holds for this position. For a long, this is a positive number (e.g. XLM quantity held long). For a short, this could be negative to indicate the amount of base asset owed (short debt) vs held. (Alternatively, use separate fields for held vs owed – see below.)
quote_amount: i128 – how much of the quote asset is held or owed. For a long XLM position, quote_amount would be negative (indicating that much USD is owed to the lending pool). For a short XLM, quote_amount is positive (USD on hand after selling borrowed XLM), and the base_amount is negative (XLM debt to be repaid). Using signed integers allows representing long and short symmetrically. Example: A 5× long: base_asset = XLM, base_amount = +500 XLM (worth $500), quote_asset = USD, quote_amount = -$400 (debt). A 5× short: base_asset = XLM, base_amount = -1000 XLM (borrowed/owed), quote_asset = USD, quote_amount = +$1000 (held from the short sale). The user’s equity is quote_amount + (base_amount * price). The contract will compute P/L from these.
entry_price: fixed – the price of the base asset at the time of position entry (this could be stored for reference/calculation of P/L or simply emitted in events).
entry_leverage: fixed – leverage at entry (for reference).
(Optional) accumulated_interest: i128 – track any interest accrued on this position’s debt if not zero-sum accounted elsewhere.
status: enum { OPEN, CLOSING, LIQUIDATED } – to mark if a position is actively open or in the middle of forced liquidation/closure (to prevent duplicate processing).
We might also store each position’s maintenance margin level at creation to quickly know its liquidation threshold (though this can be derived from current debt).
(The storage model can alternatively separate “long” and “short” positions into different maps or use separate fields for owed vs held amounts. The above unified approach (storing both asset amounts with sign) simplifies calculations by treating everything in terms of net assets.)
Indexes: The contract may maintain some indexing to optimize liquidations:
For example, a min-HealthFactor heap or sorted list of positions by health factor, updated on each price change or position update. However, maintaining such an index on-chain could be expensive. Instead, liquidation scanning is likely done off-chain by the bot. Therefore, the contract state is mostly direct mappings, and the heavy computation of finding lowest health can be done off-chain by reading all positions or by filtering events.
The storage patterns follow Soroban best practices:
Use instance storage for global config and use typed keys for maps (e.g. prefix keys with identifiers like "POS" + position_id for positions, etc., or use the SDK’s Map type).
Minimal duplication: The design avoids double-accounting; for instance, a user’s total debt in an asset can be derived by summing their positions of that asset side, so storing TotalDebt is optional. The contract might compute health factors by iterating a user’s positions (which is acceptable if per-user position count is limited or if using efficient data structures like a vector of IDs).
Asset handling: All asset balances for contracts are stored in the token contract (SAC) data, not directly in our contract. Our CollateralBalance entries are conceptual; the actual tokens are held either in the lending pool or within this contract’s custody. For example, when the margin contract holds XLM as part of a long position, those XLM are stored in the XLM SAC under our contract’s address. Similarly, owed amounts live as debt records in the lending contract. Our state simply tracks the amounts for logic.
Data Access Patterns: The contract will often need to access a user’s total collateral and total debt quickly. We ensure these are either stored or can be derived in O(n) with n = number of positions (which is typically small per user). Cross-margin means aggregated checks, so we might store an aggregate per user (like total_collateral_value, total_debt_value) updated on each position change for efficiency.
This storage layout is designed for clarity and upgradeability. If a future upgrade needs to add new fields (e.g. multi-asset collateral support or funding payments), the contract can include them in a new version. We will reserve some storage keys or follow a versioning scheme to ensure a smooth migration.
Position Lifecycle Flows
This section describes how positions are opened, managed, and closed through the contract, including the interactions with swaps and lending:
Opening a Position (Long or Short)
User Intent: The user initiates an “Open Position” via the front-end, specifying the asset (XLM), side (long or short), leverage (up to 5×), and either the position size or collateral amount. For example, “Go 5× long on XLM with $100 collateral” or “Short $500 of XLM at 3× leverage.”
Collateral Check/Transfer: The user must have sufficient collateral in their margin account. If not already deposited, the transaction will include a collateral deposit. The contract’s open_position function can accept a parameter or be preceded by a deposit_collateral call. In either case, before opening, the contract ensures the user’s available collateral ≥ size / leverage (the required initial margin)
. If the user is depositing new collateral as part of the call, the contract will call require_auth on the user’s Address and transfer the tokens from the user to itself
, then deposit into the lending pool.
Borrow from Lending Pool: Next, the margin contract determines how much to borrow:
For a Long position: Borrow the quote asset (USD) equal to position_size - user_collateral_contribution. Using the example, for a $500 position with $100 collateral (5× leverage), it will borrow $400 from the USD lending contract. The contract calls the lending contract’s borrow(user_or_contract, amount) method. The lending contract transfers $400 of the stablecoin into the margin contract’s balance (or directly to an address the margin contract specifies).
For a Short position: Borrow the base asset (XLM) that will be sold. E.g. to short $500 of XLM, at current price $0.1/XLM that’s 5000 XLM needed (if the user posted $250 collateral at 2×, it would borrow another $250 worth XLM). The margin contract calls the XLM lending pool’s borrow, receiving XLM into its custody.
Asset Swap (Trade Execution): Now the contract needs to convert the borrowed asset into the other asset to create the leveraged position:
Long: The contract now has $400 (borrowed) plus the user’s $100 (the user’s portion could either still be in the pool or also withdrawn; typically the user’s $100 remains as collateral in lending and was not converted, meaning the long position of $500 is composed solely of the borrowed $400 converted to XLM and the user still has $100 collateral in USD form. However, an alternate approach is to also use the $100 to buy XLM, maximizing exposure. For simplicity, assume we only use borrowed funds for the trade and keep collateral in place.) The contract needs to buy XLM with the $400. Smart contracts cannot directly interact with Stellar’s order books (no built-in orderbook access in contracts
), so the swap is done via a Stellar Classic Path Payment operation. This occurs in the same transaction: the user (or contract) submits a PathPaymentStrictSend op that sends $400 and receives XLM in return. The path payment sources the $400 from the margin contract’s balance and delivers XLM to the margin contract. This operation executes against the Stellar DEX, finding the best order path. By including it in the same transaction as the contract call, atomicity is ensured – either the borrow and swap both succeed, or the transaction aborts (no partial completion).
Short: The contract has borrowed XLM (say 5000 XLM). To short, it must sell XLM for USD. Similarly, a PathPaymentStrictSend (or StrictReceive) operation is added to the transaction: sending 5000 XLM from the margin contract and receiving USD to the margin contract (or to the user’s account and then immediately transferred in). The result is the contract now holds additional USD (the proceeds of the short sale). Combined with the originally posted USD collateral, this forms the user’s new total collateral pool (which is larger after the sale).
Atomic Transaction Composition: The user’s transaction thus typically has two operations: (1) an invokeContract for open_position (which handled steps 2 and 3, setting up the borrow and internal records) and (2) a PathPayment operation to swap the borrowed asset. We design the open_position function to prepare the state for the swap and possibly transfer the borrowed asset to the user’s account or a temporary escrow if needed. In practice, the simplest approach is: the open_position call ends with the margin contract authorizing the user to spend the borrowed asset amount (via an allowance or by transferring the asset to the user with the expectation it be used immediately for the path payment). Then the PathPayment operation uses the user as the source (who now has the asset or an allowance for it) and the margin contract as the destination for the swapped asset. This way, after the path payment, the margin contract ends up with the position asset.
By structuring the transaction this way, we achieve an atomic swap+borrow: if the DEX trade cannot fill (e.g. slippage too high), the path payment fails and the entire transaction (including the borrow) is rolled back. The user is thus protected from entering a position at an unacceptable price. This atomicity is crucial for DeFi parity – it mimics how a single margin trade would occur.
Position Record & Finalization: After the successful swap:
For a Long, the margin contract now holds XLM (the purchased amount). This XLM is effectively the collateral for the loan (plus the user’s original USD collateral which remained in lending). The contract records the new position: e.g. user now has base_amount = +N XLM and quote_amount = -$400 debt. The $400 debt is recorded in the lending pool under the margin contract (or user’s account, depending on implementation; likely the contract is the borrower on behalf of user). The user’s equity is $100 (in USD terms), which is stored as their collateral.
For a Short, the contract holds additional USD (from selling XLM). The user’s position record might show base_amount = -M XLM (owed) and quote_amount = +(user_collateral + sale proceeds) USD. The contract will have repaid itself the XLM borrow by handing it off to the DEX in exchange for USD. Actually, more precisely: the contract borrowed XLM from the pool, immediately sold it, and now owes that XLM amount back to the pool. That XLM debt is recorded, and the contract holds the USD (collateral + profit from sale) to cover it.
The contract finalizes by updating its state mappings (adding position ID to the user’s list, etc.) and emitting the PositionOpened event. The event will include the effective entry price (which can be derived from how much USD was spent for how much XLM received, as returned by the path payment result).
Result: The user now has an open leveraged position. No further user action was needed beyond signing the transaction. The position is tracked entirely on-chain. The user’s cross-margin account now reflects:
Increased total debt (e.g. $400 stablecoin debt for the long, or XLM debt for the short).
Increased holdings of the opposite asset (e.g. XLM held long, or extra USD held from the short).
The health factor of the account will have dropped to some level above 1 (hopefully), indicating how much buffer remains before liquidation.
(Note: The above sequence assumes the margin contract is the one interfacing with the DEX via path payment. In practice, because contracts themselves can’t initiate a path payment by their own logic, we rely on the user’s transaction to include it. One pattern is to use Soroban Authorized Invocation to have the contract sign an allowance for the user. Alternatively, the contract could hold the asset and the user’s account be the destination of the path payment, after which the user immediately invokes a second contract call to deposit the received asset into the contract. However, that would require two transactions or complex sequencing. To keep it atomic, we likely allow the user to be the actor for the swap while the contract pre- and post-conditions ensure the assets end up where needed. This is an implementation nuance; the key point is atomicity.)
Increasing a Position
To increase an existing position’s size, the flow is similar to opening a new one, but acting on an existing record:
The user might call increase_position(position_id, additional_size) and optionally provide more collateral or use free collateral. The contract will fetch the specified position (ensuring it’s still open and belongs to the user).
It then performs the same steps: calculate additional margin needed for the increase, ensure it’s available, borrow the appropriate amount from the lending pool, and execute a path payment to buy/sell more of the asset to add to the position. For a long, it borrows more USD and buys more XLM, concatenating to the position’s XLM holding. For a short, borrows more XLM and sells it for USD, adding to the USD collateral held.
The position’s stored base_amount and quote_amount are updated (e.g. base_amount increases for a long, becomes more negative for a short). We may recalc an average entry price if needed for reporting.
Events: PositionIncreased is emitted.
Reducing or Partially Closing a Position
A user can reduce a position to realize profits or limit losses:
The user calls reduce_position(position_id, reduce_size) indicating how much of the position to close (e.g. close 50% of a long).
The contract will determine the portion of assets to trade and debt to repay. For a long, if reducing by some amount, it will calculate the corresponding XLM amount (base asset) to sell. It then transfers that XLM out to the user (or directly uses contract funds) and expects a path payment to occur sending XLM and returning USD. In an atomic transaction, this can be done similarly with two ops: the contract invocation prepares the state (e.g. marking how much debt to repay) and the path payment executes the sale of XLM for USD, crediting the margin contract with the USD.
Upon completion, the contract uses the received USD to repay the loan. It calls the lending contract’s repay function for the amount of debt being closed. This reduces the user’s debt by that amount in the lending pool. (Repayment could be done either by the path payment delivering funds to the lending contract address via a claimable balance, or simpler: deliver to margin contract, then margin contract calls repay. The latter is straightforward.)
The position record is updated with a smaller base_amount and debt. If the reduction was 100% (reduce_size equals the full remaining size), this effectively closes the position (similar to below).
Emits PositionReduced event.
Partial closes free up some collateral (for longs, some USD from the sale might remain after repaying proportional debt, effectively profit; for shorts, some XLM might remain after buying back what’s owed for that portion). That freed value stays in the user’s margin account as idle collateral, which they can withdraw or use for other positions.
Closing a Position Fully
Closing is just the special case of reducing the entire position:
User calls close_position(position_id). The contract checks the position’s current amounts.
It then facilitates a full swap:
For a long: transfer out all XLM held in the position to be sold. A path payment in the transaction sells all XLM for USD (to at least cover the debt). The contract receives USD.
For a short: the contract will use the USD it holds to buy back XLM. If the contract already holds enough USD (collateral + sale proceeds) to cover the owed XLM, it can directly call repay by converting internally. But since we cannot convert without a DEX, we do a path payment: send USD, receive XLM. The XLM goes directly to the lending pool repay or to the contract which then calls repay.
After the swap, the contract has the asset needed to repay the entire loan:
Long: now has USD equal to the borrowed amount plus any profit. It calls lending repay(amount=$400) to clear the debt. Any surplus USD (profit) beyond the debt is the user’s profit – the contract can leave it as the user’s collateral balance or transfer to user (the user might withdraw it subsequently).
Short: now has XLM that was bought back. It repays the XLM debt to the lending contract. If there is leftover USD in the contract (not all USD was needed to buy back the XLM because price fell, yielding profit), that leftover remains as user collateral/profit.
If there was a loss, meaning not enough of the position asset was recovered to cover the debt, the difference would eat into the user’s collateral (the contract would have had to use some of user’s initial collateral to fully repay the loan). In that case, the user’s collateral balance will drop accordingly.
Remove the position entry from storage (to save space and prevent reuse of ID).
Emit PositionClosed with the final P/L.
After closing, the user’s remaining collateral (if any) is still in their cross-margin account and can be withdrawn or used for other trades. All interest owed is paid up at the moment of repay (the lending contract would have included any accrued interest in the required repay amount).
Liquidation Process (Forced Close)
Liquidation is the fail-safe path when the user’s position moves against them beyond the allowed limit. The margin contract constantly (or periodically) checks each account’s health factor:
Health Factor (HF): defined as HF = collateral_value / (debt_value * maintenance_margin) for the account. Alternatively, define margin ratio = equity / position size. If HF drops to 1 or below, it means the account equity equals or is less than required maintenance
 – the user can no longer sustain the losses.
When HF ≤ 1 (or margin ratio below threshold), the position(s) are eligible for liquidation:
Automatic Trigger: The design aims for automated liquidation as primary. This can be achieved by coupling with the price oracle updates. Each time Reflector Oracle publishes a new price (which happens every ledger or every few seconds), a trigger function can be invoked. For example, the oracle update transaction itself could call a function check_liquidations(asset) on the margin contract. This function would:
Fetch the updated XLM price from the oracle.
Iterate over positions (or accounts) that involve that asset, computing their collateralization. (We can maintain a list of at-risk positions to narrow this down.)
Identify any position or account with HF below 1.
For each such position, execute an internal liquidation routine (or flag it for liquidation).
However, actually executing the full swap and repay within the contract requires an external actor to provide funds (since the contract itself cannot conjure the counter-asset). What the contract can do automatically is seize collateral up to the debt value and mark how much debt is cleared. A fully automated on-chain liquidation might work like: use oracle price as a reference to determine how much of the collateral to seize to cover the debt, then cancel the position. But because of no on-chain orderbook, to actually convert that collateral to repay debt, we still need someone to trade it. Therefore:
The contract could automatically mark the position as liquidated and transfer the collateral to a designated auction account or even to the lending pool (as payment in kind), but without a trade the debt isn’t truly paid unless the pool accepts collateral asset directly (unlikely, unless it’s same asset).
More realistically, the “automated” part will be the detection and invocation of the liquidation function by a trusted agent. We envision the Reflector oracle or another bot calling liquidate(position) immediately when HF crosses threshold. This still counts as automated (no user action required) but is implemented as an off-chain service automatically reacting. In summary, the contract provides the function and the oracle/bot provides the trigger.
Liquidation by Bot/Arbitrageur: When liquidate(position_id, liquidator) is called (by anyone), the contract first recomputes the latest HF using the oracle price to double-check the position is below maintenance. This uses lastprice() from Reflector within the contract
 to get the current values. For example, if XLM plummeted and the user’s equity is now only 5% of position, HF < 1.
The contract then determines the maximum repayable amount in this liquidation call. Often protocols allow partial liquidation (e.g. up to 50% of debt) to avoid overshooting. We can implement a parameter like LiquidationFactor (e.g. 50%) so that each liquidation call can cover at most half the debt, giving the user a chance to recover if market rebounds slightly. For simplicity, we might liquidate the position entirely in one go if it’s small or severely underwater.
The liquidator must supply the debt asset:
For a long (debt in USD): the liquidator will pay in USD to the contract.
For a short (debt in XLM): the liquidator will pay in XLM.
The contract uses the received funds to repay the debt in the lending pool (calling repay). This immediately reduces/clears the user’s debt with the pool.
In return, the contract transfers the collateral asset to the liquidator at a discount. Essentially, the liquidator is buying the collateral. We calculate how much collateral to give: e.g. if liquidator paid $400 and the bonus is 5%, they receive $420 worth of XLM (by oracle price). The contract would transfer that amount of XLM out of the user’s position to the liquidator. The difference (an extra $20 worth) is the liquidator’s profit, and equivalently the user’s remaining equity is eaten by that amount as a penalty.
Update position: reduce the position’s size and debt accordingly. If it was a full liquidation or if the position becomes positive equity, close it out. Often, liquidation either fully closes the position or leaves a very small remnant. In cross-margin, if multiple positions, we might liquidate the largest losing position first
. But since initially we have one asset, we just target that position.
Emit PositionLiquidated event.
The user has effectively lost a portion or all of their collateral. Any leftover collateral after paying the liquidator and repaying debt would remain in their account, but in a near-complete liquidation scenario, that leftover might be zero or very small.
Post-Liquidation: If the position was only partially liquidated (debt partially repaid), the user still has that position open but smaller, and still owes interest on remaining debt. Often, protocols continue to allow partial liquidation until the account is healthy. We will allow repeated calls until HF > 1 again. If the liquidation fully closed the position, remove it and the user’s collateral might now be just the tiny remainder if any.
Fallback Safety: The liquidation bot run by Peridot will ensure that if for any reason a position isn’t liquidated automatically (perhaps no one calls the function when needed, or oracle updates lag), it will call liquidate as soon as it detects an unhealthy position. In practice, the bot will subscribe to oracle price feeds and compute health factors off-chain for all positions, then submit liquidation transactions for those below threshold. Because anyone can call liquidate, arbitrageurs could also step in (especially if the DEX liquidity allows them to profit from a better price than the oracle price used for collateral – but our design probably uses oracle price to set the terms, removing market risk for the liquidator).
Collateral Seizure vs Market Sale: A design decision: our contract uses fixed oracle prices to decide how much collateral to hand over for a given debt repayment. This avoids needing an on-chain market sale at the moment of liquidation (since the liquidator effectively does the conversion off-chain: they give stable and get XLM, which they can sell themselves if needed). This is similar to how Compound/Aave handle it – the liquidator repays a portion of debt and receives a fixed discount on collateral
. This is safe as long as the oracle price is reliable (Reflector provides a decentralized, trade-weighted price feed). We must ensure the oracle price is fresh (e.g. using a short TWAP or latest trade). Reflector’s network design provides continuous updates from Stellar DEX trades, so it’s fairly real-time.
In summary, the lifecycle for a position is:
Open – borrow and swap executed atomically, position recorded.
Increase – borrow and swap more, update position.
Reduce – swap back part, repay part, update position.
Close – swap back all, repay all, position removed.
Liquidate – third-party triggers swap (implicitly by paying debt and taking collateral) when user fails to maintain margin, position forced closed with penalty.
Through each step, the contract works in tandem with Stellar’s payment operations to perform the necessary asset exchanges, given Soroban’s limitations on direct DEX access. All critical state changes (debt, collateral balances, positions) occur within the contract’s logic, ensuring consistency.
Transaction Composition and Atomicity
Because Soroban contracts cannot directly interact with Stellar order books, achieving atomic margin trading requires careful transaction construction using classic operations. The pattern is to combine contract calls with Path Payment operations in a single transaction so that fund movements and swaps happen together or not at all. Atomic Open Position Example: When opening a long position, the client (frontend) will build a transaction with multiple ops:
Invoke open_position – source account = user. This prepares the margin contract state: reserves/borrows the necessary amount and possibly transfers the borrowed asset to the user (or sets an allowance for the user to spend it). The result of this operation is that the user is authorized to perform the swap with the borrowed funds
.
PathPaymentStrictSend – source account = user (or the margin contract if it’s possible via contract authorization). This operation sends, for example, $400 of USDC (that the user now has access to) to the margin contract, in return for XLM. The destination is set to the margin contract’s address (specifically its SAC balance for XLM). The path payment will consume offers on the Stellar DEX to convert USDC to XLM. We set destMin to ensure we get at least the expected XLM (or the transaction aborts if price slippage is too high).
(Optionally) Invoke finalize_open – if needed, a second contract call could be used to finalize the position with the results of the swap. In many cases this may not be necessary if the contract already accounted for it, but it could be used, for instance, to record the actual amount of XLM received (entry price calculation) and to clean up any temporary allowances.
All these ops are in one transaction, signed by the user. If any step fails (e.g. the DEX doesn’t have enough liquidity to fill the swap within destMin bounds, or the contract logic throws an error like insufficient collateral), the whole transaction fails (atomicity). Thus the user either opens the position fully at known parameters or not at all. Atomic Close Position Example: Similarly, to close a long, a transaction might do:
Invoke prepare_close(position) – contract marks position closing, possibly transfers XLM from contract to user or sets user allowed to spend XLM from the contract.
PathPaymentStrictSend – source = user, sends XLM (from the position) to exchange for USDC, destination = margin contract. Now the margin contract receives USDC.
Invoke finalize_close(position) – contract uses received USDC to repay debt and updates/removes the position, calculating P&L.
This ensures the debt is only considered repaid if the swap succeeded in getting the needed USDC. If the market movement during transaction submission is unfavorable and the path payment can’t get enough USDC to cover the debt (within allowed slippage), the transaction can fail and not close the position, preventing a scenario where debt is left unpaid. Liquidation Transaction: In a liquidation, the atomicity is slightly different because the liquidator provides one asset and receives another:
The liquidator (could be the bot) will call liquidate(position) providing, say, the USDC to repay. That single contract call is sufficient, as the contract will immediately transfer XLM collateral to the liquidator. There is no DEX trade in this step; the “swap” happens conceptually using the oracle price (the liquidator essentially buys XLM at a fixed price). The liquidator then might do a separate transaction to sell that XLM on the market, but that is outside the margin contract and not atomic with the liquidation (not necessary to be atomic, since the liquidator is willing to accept the market risk after obtaining the collateral at a discount). If we wanted to be extremely fancy, a liquidation could also be done via a path payment: e.g., liquidator calls a combined op where they send USDC to margin contract and specify in path payment that margin contract’s XLM goes to them, but that’s unnecessarily complex. Simpler is contract internal transfer as we have it.
Stellar Classic Involvement: All swaps use Stellar Classic PathPaymentStrictSend or StrictReceive operations
. The margin contract relies on these for price discovery and trade execution. We specifically use PathPayment because it allows specifying source asset and destination asset with the network finding intermediate order book paths. The contract itself cannot call a path payment; it’s the transaction that does, using the user or liquidator as the source account (since they hold the asset that’s being exchanged at that moment). The margin contract’s role is to set up allowances and receive the output. Explicit Authorization: Throughout these flows, Soroban’s require_auth is used to authorize any transfer from user accounts
. For instance, when the contract transfers collateral from the user or when the user spends the borrowed asset, the user’s signature (which is on the transaction) is checked against require_auth calls in the contract. This ensures the user approves of the contract taking their funds or of the borrowed funds being used for the swap. Soroban’s auth framework allows multi-party signature in one transaction if needed
 – e.g., if the contract required both the user and a third party to sign, it could. In our case, typically only the user’s signature is needed for their own operations. The contract and lending pool do not have private keys; their actions are authorized by the protocol and by the user’s consent. State Integrity: By using atomic transactions, we avoid issues where a borrow happens without a corresponding swap or vice versa. The contract only finalizes state changes (like recording a new position or marking one closed) if the swap and loan operations all succeed. If something fails, the Soroban transaction will revert any interim state changes (the ledger entries are only committed on success). Fee Considerations: Each operation in a transaction consumes fees. Combining multiple ops (contract invocation + path payment) is heavier than a single op, but still efficient. Since this is on testnet (and later mainnet), the design assumes the user is willing to pay a slightly higher fee for the convenience of atomic execution. This is similar to Ethereum transactions which call multiple contracts – the cost is higher but acceptable for a complex action like leveraged trade. In summary, transaction composition ties everything together:
Users and bots use multi-op transactions to ensure complex multi-step operations happen safely.
The margin contract is designed to work hand-in-hand with these operations, using allowances and interim transfers to bridge between contract logic and DEX trades.
This approach aligns with Soroban’s model where some logic lives in the contract, and some (like path finding) remains in the classic layer.
Risk Engine and Margin Requirements
The risk management engine ensures that users cannot exceed allowable leverage and that their positions are liquidated before losses exceed collateral. Key elements:
Leverage Limits: The contract enforces a maximum of 5× leverage for any new position. This corresponds to an initial margin requirement of 20% of the position’s notional value
. When open_position is called, it calculates required_collateral = position_size / leverage. If leverage requested is >5 or if the user tries to open with less than 20% collateral, the contract will reject the transaction. For example, a user wanting to open a $1000 position must provide at least $200 collateral at 5×. They can choose to use more than minimum collateral (for a more conservative leverage).
Initial vs Maintenance Margin: We maintain two levels:
Initial Margin (IM): ~20% (for 5×) – this is checked on position open/increase. It’s the minimum equity to start a position. Users can of course supply more than IM, which effectively reduces their leverage. The contract won’t allow starting a trade if collateral_contributed < IM * position_value.
Maintenance Margin (MM): e.g. 10% – the minimum equity ratio to keep the position open
. If the user’s equity falls below 10% of position value, they are in margin call territory and liquidation can happen. We set MM somewhat lower than IM to give a buffer for market fluctuations. The exact percentages can be tuned via admin based on volatility.
Health Factor (HF): We define HF = collateral_value / (debt_value * (1 + liquidation_penalty)). Alternatively, HF can be simplified as collateral_value / debt_value and compare to a threshold. If HF < 1.1 (for 10% maintenance + perhaps 0% penalty), then liquidation needed. However, since we give a 5% bonus to liquidators, effectively the position needs ~105% collateral to debt to be safe from immediate liquidation. We incorporate that in thresholds. The contract likely uses a simpler measure: Collateral ratio = (Collateral / Debt). Liquidation threshold might be 1.1 (110%) meaning if Collateral/Debt < 1.1, liquidate. This accounts for 10% maintenance + some buffer.
The contract computes HF or collateral ratio each time it needs to evaluate a position. It uses current prices from the oracle to value the collateral and debt in the same terms (likely USD).
Example: User long XLM: collateral $100, debt $400, XLM held $500 value initially. If XLM price drops 18%, XLM holding value maybe $410, debt still ~$400 (plus some interest). Collateral (equity) now $410-400 = $10, which is 2.5% of position – well below 10%. HF = $410 / $400 = 1.025, which is below 1.1, triggers liquidation.
Interest Accrual: Because positions are backed by actual loans in the lending protocol, interest accrues on the borrowed amount over time. The margin contract’s risk engine must consider this growing debt. It can query the lending contract for the current owed amount when computing HF. The lending contract likely uses a continuous interest index; the margin contract could either:
Periodically update the stored debt amounts by reading the index (e.g. whenever user interacts or at liquidation time).
Or simply call something like getBorrowBalance(user, asset) on the lending pool, which returns the current principal + interest. This would give an up-to-date debt_value.
The health factor calculation would use that increased debt. This means even if asset prices don’t move, a user’s HF will slowly decline as interest grows, potentially leading to liquidation if they never repay interest. This is intended behavior (as with any margin loan – interest can eat your margin).
Margin Calls: Our design doesn’t have an off-chain “margin call” notice aside from approaching liquidation. However, the UI could warn users if their HF falls below, say, 1.25 (125%) that they are in danger. Users can respond by adding more collateral (calling deposit_collateral) or reducing positions. Because cross-margin aggregates risk, adding collateral benefits all positions.
Cross-Position Netting: Since it’s cross margin, the risk engine considers the total collateral vs total debt of the account:
If a user has multiple positions, we calculate aggregate collateral value = sum of (held assets * price) + any idle collateral, and aggregate debt = sum of all owed assets * respective price. For example, if one position is hugely losing and another is winning, the gains of one increase collateral value which can offset the losses of the other
. We allow that – which is the advantage of cross margin.
The maintenance margin applies to the overall account (we don’t necessarily liquidate each position individually if others are covering it). In practice though, it might liquidate specific positions one by one, but decided by which position is most underwater. Likely, we target the largest losing position first
 to reduce risk quickly. In our initial implementation, since only XLM/USD is traded, all positions will lose equity when XLM moves one way, so it may not matter. But if we had multi-asset, we’d pick the one with worst P/L.
Risk Parameters Storage: The initial and maintenance margins and liquidation bonus are configurable by admin. This allows adjustment as market conditions change. For example, if XLM becomes more volatile, the admin could raise maintenance to 15%. Changing these parameters would only affect new operations (existing positions would effectively have to adhere to the new rules for liquidation if applicable).
Interest Rate Risk: The lending pools have interest rates (likely variable). If interest rates spike, user debt can grow faster. This can cause “margin call” even if price is stable. The system handles this seamlessly by including debt growth in HF. If debt grows too high relative to collateral, liquidation can trigger. This is analogous to how, in traditional margin, funding payments or interest can erode equity.
Limit and Stop Orders: (Out of scope for now) We note the system doesn’t inherently support user stop-loss or take-profit orders; the user must manually close or rely on liquidation. In future, one could integrate an on-chain stop order via the AI agent or bots, but currently we assume user/bot does this off-chain.
The goal of the risk engine is capital preservation: ensure the protocol (lending pools) do not incur bad debt. By liquidating at a collateral ratio > 100%, there should always be slightly more collateral than debt when a position is liquidated, meaning after the liquidator’s cut, the debt is fully covered. For instance, liquidating at 110% CR with 5% bonus leaves ~5% excess theoretically, which acts as insurance. If the market moves extremely fast (gap risk), it’s possible collateral value plunges below debt before liquidation can execute – in that case the lending pool might take a loss. We mitigate this by using real-time oracle feeds and by designing the system to act quickly (each ledger if needed). The Stellar network’s fast finality (5 seconds) and our automated triggers should minimize this risk.
Oracle Integration (Reflector Price Feeds)
For accurate margin calculations and liquidations, integration with the Reflector decentralized oracle is critical:
Reflector Oracle Contract: The contract address for Reflector’s price feed (likely a single contract providing multiple asset prices, or one per asset pair) is stored in our config. Reflector reports prices for Stellar network assets by observing DEX trades
. For our use case, we’ll configure it to provide the XLM/USD price (where “USD” corresponds to whatever stablecoin asset we use, possibly an anchored USDC on testnet).
Price Query: Within the margin contract, whenever we need the current price of XLM, we create a client instance of the oracle contract and call its function. Based on Reflector’s interface, this might look like:
let oracle = PriceOracleClient::new(&env, &OracleContractID);
let price_data = oracle.lastprice(&Asset::Native);  // assuming XLM is native
let xlm_price = price_data.price;
The lastprice method returns a struct containing the price (likely as an integer with a predetermined decimals precision)
. We also might call oracle.decimals() to know how to scale the price
. For instance, if decimals = 7, a price of 0.1234567 USD/XLM might be represented as 1234567 (with 7 decimal places). We will handle that scaling in our math.
Continuous Updates: Reflector nodes will update the oracle contract each ledger with the latest price. This means our margin contract can always fetch a fresh price when a user takes an action. We do not need to store the price internally, except maybe for logging P/L at entry/exit. Instead, on each relevant function:
On position open: fetch current price to calculate how much asset to buy and to record entry price.
On margin check (liquidation or withdraw): fetch current price to compute collateral vs debt.
On close: fetch price to compute expected return.
Essentially, any time a price is needed, we query the oracle on-chain, ensuring we’re using the latest data and not relying on stale info.
Oracle Push vs Pull: Our contract primarily pulls prices when needed. We also plan to allow the oracle (or an affiliated bot) to push an update to trigger liquidation checks. For example, we might implement an admin-only or oracle-only method update_price_and_check(Asset) that can be invoked by the oracle. The oracle contract itself could possibly call into our contract as part of its update transaction (though cross-contract calls initiated by another contract’s update might be complex; a simpler approach is the oracle aggregator externally includes a call to our contract).
Price Accuracy & Security: Reflector’s feed is trusted as a decentralized source. It uses multiple nodes and the Stellar DEX itself for data, mitigating manipulation. We nonetheless must consider:
Use a short TWAP (Time-Weighted Average Price) if possible for liquidation to avoid a momentary spike/drop triggering unfair liquidation. Reflector might offer a twap(asset, period) method
. We could take a 1-minute TWAP for health checks. However, in a fast market crash, TWAP might be higher than current, delaying liquidation. The design could opt for last traded price for speed. We strike a balance by possibly using last price for trigger, but still requiring a slight maintenance buffer to avoid hair-trigger on single trade blips.
Precision: The oracle price precision (say 7 decimals) should be high enough for small movements. We’ll do all calculations in integer math (i128) to avoid floating errors, aligning units carefully (e.g. if XLM price is 0.10, price might be stored as 10^7 * 0.10 = 10000000? Actually if 7 decimals, 0.1 = 1000000).
The oracle feed provides prices of many assets in a unified way. We just need one pair initially. But the architecture supports adding more asset feeds (e.g. if we later allow BTC or ETH margin trading, we’d add those asset IDs and call oracle for each).
Update Flow Example: Suppose the price of XLM moves from $0.10 to $0.09 due to a sell-off:
Reflector nodes see trades on Stellar DEX reflecting ~$0.09. They update the oracle contract’s stored price for XLM/USD this ledger.
Our margin contract doesn’t automatically know this until it’s either queried or an external call is made. The liquidation bot will likely query the oracle off-chain every few seconds as well to detect such moves. If a user makes any transaction (like tries to open/close), the contract will fetch the new price then.
For faster response, we can have a dedicated function on_price_update() that the oracle or bot calls. This function could loop through a list of potentially affected accounts. However, iterating all accounts on a single price update might be too heavy. Alternatively, it could emit an event or flag accounts that need liquidation, and then the bot can call liquidate for each.
Given performance concerns, it’s acceptable to rely on the bot to perform the loop off-chain and call individual liquidations. The oracle integration’s main job is providing accurate data when called.
Oracle Trust Model: We rely on Reflector network’s correctness. The margin contract is effectively trusting the oracle contract’s reported price. To guard against oracle malfunction (reporting an absurd price), the protocol might implement sanity checks (e.g. compare to last known price, or have a second source as fallback). Initially, we assume Reflector is robust. It’s worth noting that if the oracle was compromised and fed a very low XLM price, many longs could be liquidated cheaply. This is a known risk in DeFi – mitigated by using decentralized oracles. Reflector is decentralized, but we should still monitor it.
In code, integration is straightforward using the client stub provided by Reflector’s SDK:
let px = oracle.lastprice(&Asset::Native).expect("No price");
if px.price == 0 {
   // handle error
}
let xlm_usd_price = px.price;  // scaled by oracle.decimals()
We then convert token amounts to a common base (USD) for comparison:
For long: collateral is USD, debt is USD, XLM position value = XLM_amount * price (divide by 10^decimals).
For short: collateral in USD (including sale proceeds), debt in XLM which we convert to USD by * price.
The Reflector oracle decouples our contract from having to find prices via on-chain trades (which is impossible in Soroban for now). It provides immediate data availability at low cost
. This aligns perfectly with our needs: every margin protocol must have a reliable price feed for collateral and asset valuation.
Liquidation Logic and Safety Mechanisms
Liquidation has been touched on, but here we detail the logic and how it aligns with Soroban constraints and incentives:
Automated Liquidation Trigger: The margin contract itself does not run on a timer, so “automation” comes from external triggers. We plan two layers:
On-Chain Trigger via Oracle: As described, the oracle update transactions can include calls to check liquidations. If this is implemented, the oracle (or a special daemon monitoring prices) would effectively call a method like evaluate_margin(user) for specific users or small batches. Perhaps it could even call liquidate directly on a particularly bad position. There is a limit to how much one transaction can do (compute and write limits), so it cannot liquidate dozens of positions at once. Therefore, this method would likely just flag or handle one at a time. For example, if price drops drastically, the oracle might call liquidate(position_X) of the worst position that it knows became undercollateralized. Subsequent ledger, it might call the next, etc. This provides a semi-automatic clearing.
Off-Chain Liquidator Bot: Running concurrently, the Peridot liquidation bot (from peridot-bots/liquidator) monitors all positions via Horizon or Soroban RPC. It will identify any account with HF below threshold and immediately submit a liquidate transaction for it. This bot ensures no straggler escapes – it’s essentially the same role as liquidator bots in Compound/Aave. In fact, multiple independent bots could do this for profit, given the incentive.
Incentive Mechanism: The 5% liquidation bonus (configurable) is the incentive for external actors to perform liquidations promptly. This is generous enough to cover transaction fees and slippage. If a position is large, liquidators might need to handle selling collateral on the market after receiving it, but the 5% cushion makes it profitable as long as market prices haven’t dropped more than that further during execution.
Liquidation Flow in Detail: (Long position example)
User has $50 collateral, $450 debt, HF = ~0.11 (just at edge). Price dips slightly, HF goes to 0.98.
Liquidator bot sees this and calls liquidate(pos_id, its_address) providing $450 of USDC to the margin contract.
Margin contract checks price (say XLM now $0.09, so position XLM worth $405). Collateral value = $405, debt = $450, definitely under 110%. It approves liquidation.
It calculates how much XLM to give for $450. Using oracle price $0.09, $450 would normally buy 5000 XLM. With 5% bonus, liquidator should get 5000 * 1.05 = 5250 XLM. Does the contract have 5250 XLM? The user’s position only had ~4500 XLM (because $405 worth at $0.09 is 4500). There’s not even enough XLM to give 5250. This means the user’s collateral isn’t enough to cover full debt plus bonus – which is expected when HF < 1. We can’t give what we don’t have; so in this scenario, the contract would give all 4500 XLM it has (effectively the liquidator gets ~4500/5000 = 0.9 of their desired 5250, meaning they actually got a smaller bonus, maybe ~0% in this case – they basically break even or slight loss). However, in practice, we would not allow a liquidator to repay more debt than the collateral can cover with bonus. So we would set a limit: max repay = collateral_value / 1.05. If $405 collateral, max repay ~ $386. The liquidator bot should ideally only repay $386, not full $450, in the first attempt. Partial liquidation would bring the position to safer levels. Perhaps our contract always liquidates only a portion such that after liquidation, the collateral ratio goes back to, say, 150%. The rest can be liquidated later if needed.
So adjusting: the contract might compute max_repay = collateral_value / (1 + bonus) and use min(user_supplied_repay, max_repay). If user supplied $450 but max is $386, it will only use $386 of what was provided (and return or not take the rest). The liquidator can call again for the remainder.
With $386 repaid, given price $0.09, it gives ~386/0.09 = 4289 XLM *1.05 bonus factor = ~4500 XLM to liquidator, which exactly exhausts the collateral. Debt left = $450-386 = $64. Collateral left = $0 essentially. The position is almost closed but still owes $64 with no collateral -> this is bad debt now. To avoid leftover debt, it’s better to overshoot slightly: liquidate to 0 collateral but leaving some debt means the pool lost money. To avoid that, liquidation logic might actually allow using all collateral to repay as much as possible, and if any debt remains, mark it as bad debt to be covered by protocol reserves. But ideally our parameters (maintenance margin and bonus) are set so that at liquidation threshold, collateral covers at least 105% of debt. If user’s HF was much below 1, then indeed shortfall occurs.
A practical design: target HF after liquidation. We could aim to only partially liquidate to bring HF to maybe 1.25 (so user has some cushion). In above scenario, the first partial liquidation might not wipe all collateral, just enough to restore health. If the price keeps falling, another round triggers. This is safer for protocol than waiting and doing one big liquidation when collateral is almost gone. Many protocols do partial liquidations (like 50% of debt at a time).
For simplicity, let’s incorporate: We liquidate at most e.g. 50% of debt in one call, or at most until collateral = 2 * debt (a chosen safe ratio).
Liquidation of Multiple Positions: If user has multiple positions (e.g. long XLM and long Y asset), a single liquidation call could allow specifying which asset’s debt to repay. Or the contract might liquidate whichever gives the best outcome. To keep it simple, our interface liquidates one position (position_id). In cross margin, theoretically the liquidator could repay any of the debts and receive any collateral. But since positions are separate entries, we do it position by position. We assume if one goes bad, likely all are under pressure unless they are hedged.
Protection Against Self-Liquidation Exploit: Sometimes users might try to manipulate oracle delays or slip in a withdrawal before liquidation. Our design ensures:
Withdrawals require maintaining margin after the withdrawal, so a user can’t withdraw and immediately default – the contract won’t allow a withdrawal that would drop HF below a safe buffer.
The oracle feed is near real-time, so there’s little window to game it. There’s no user-specified price – all comes from oracle.
Liquidation function uses the same fresh oracle price that any user action would, so a user can’t rely on outdated pricing.
If the oracle update frequency is each ledger, a rapid intra-ledger crash could still pose risk. But at 5-second blocks, this is minimal.
Lending Contract Interaction: During liquidation, when we call repay, that will burn the debt for the user/contract in the lending pool. If the lending pool also had a concept of collateral, we might need to withdraw it. But since we manage collateral separately (we deposited user collateral in pool at open), how do we handle that on liquidation?
If user’s own collateral (USD) was in the pool, perhaps the contract withdraws it as part of closing the account. But in a long, user’s collateral wasn’t converted, it’s sitting as deposit in pool. On liquidation of a long, ideally we use that deposit too. Actually, that deposit is still the user’s – we could directly use it to repay part of debt (internal netting in the lending system if same asset).
It might be easier to think: for long XLM, user collateral was USD in pool. When liquidating, we should apply that USD to the debt first (since it’s already there). That means in effect the user’s deposit will be reduced to cover some debt (that’s like internal collateral usage). Perhaps the lending contract itself would do that if user defaults (like seize collateral).
But because our design separated margin from lending, we have to implement that logic: e.g. as soon as HF <1, we could withdraw the user’s USD collateral from the pool and use it to repay part of their loan, before even involving a liquidator. But that’s essentially a partial auto-liquidation.
For simplicity, in our flows above, we didn’t explicitly withdraw collateral from pool on liquidate; we let a liquidator come and repay. This might leave the initial collateral still in pool which after repay becomes surplus. Actually if a long gets liquidated, after debt is repaid, the user’s $100 deposit might still be in pool. The contract should allow the liquidator to also claim that? Or the protocol keeps it? Ideally, the user forfeits it to cover remaining debt.
Possibly, the contract on liquidation will withdraw all the user’s collateral from lending pool and give it to liquidator as part of collateral. Essentially treat that collateral the same as the purchased asset. But in our long example, the collateral was USD in pool and the position asset was XLM in contract. The liquidator repaid in USD and got XLM. The user’s USD collateral is still untouched. Actually, that’s not right: If we left user’s $100, the user could withdraw it after liquidation, which is unearned because they got liquidated but kept initial collateral.
To prevent that, we must ensure the user’s collateral is also consumed in liquidation. In a long, the user’s collateral (USD) was not part of the XLM we seized. We should seize it too. That means when we detect under-collateral, the contract should also take the user’s USD deposit out and count it as part of available funds for liquidation.
Implementation: If user has collateral in the same asset as debt (USD in long case), the contract can directly apply it to the debt (calling repay from that balance) before requiring external pay-in. So in the example, user had $100 deposit; when liquidating $400 debt, contract first uses $100 to repay, leaving $300 debt. Then the liquidator only needs to pay $300 and gets XLM. The user’s $100 is gone to lender, which is correct.
If user’s collateral is a different asset than debt (in future multi-asset scenario), contract would swap it or have to liquidate that too – complicated. But initial assumption, collateral and debt asset are the same type (USD) for long positions, so it’s fine.
For short, user’s collateral is USD too (the same asset as we owe? Actually we owe XLM, collateral is USD – different asset, can’t directly repay XLM with USD without swap. But in short, we had extra USD from selling, which is basically also collateral to buy back XLM).
So consistent approach: Always apply any quote-asset collateral to repay quote-asset debt automatically, and apply any base-asset collateral to repay base-asset debt automatically, before involving external liquidators. In our single-market case:
Long: collateral USD can repay USD debt.
Short: collateral USD cannot directly repay XLM debt. However, in a short, most of collateral is already in USD from sale, which is exactly what’s needed to buy back XLM. The contract could itself perform an automatic buy if possible when close to liquidation (like a Dutch auction). But lacking that, we rely on liquidator to bring XLM.
At least for long positions, the contract will always use up the user’s stablecoin collateral to reduce the owed amount in a liquidation scenario (effectively margin call = user’s collateral gets consumed).
The remainder, if any, requires external asset – which is what the liquidator provides.
This logic ensures no user collateral “escapes” liquidation. The events should reflect that the user lost their collateral.
Liquidation Example Revisited (with collateral usage): User long with $100 collateral, $400 debt. Price drops:
Contract auto-uses $100 to repay part of debt (maybe triggered in the same liquidate call or a prior internal check). Now debt $300 remains, and the contract holds correspondingly fewer XLM (still $300 worth, since some XLM would have been sold if we had done a swap of that $100? Actually, since it’s USD debt, using $100 from collateral directly reduces debt to $300 without needing a trade).
The liquidator now only needs to pay $300 to cover remaining debt, and receives XLM worth $300 * 1.05 = $315 (assuming enough XLM present).
The user’s $100 is gone, and their position is closed. If there’s any XLM left (maybe not, since $315 worth given to liquidator covers $300 debt leaving perhaps a tiny residual XLM or none), that residual would be basically 0.
The pool got fully repaid ($400 total: $100 user collateral + $300 from liquidator), no bad debt. The liquidator got $315 of XLM for $300, likely can sell it around $300 (some profit after accounting any slippage on selling that $315 of XLM).
The user is left with nothing (they lost all $100).
This outcome is expected: user loses their margin in a liquidation. The liquidator profit comes partly from user’s collateral (that’s the penalty). Security in Liquidation:
We ensure only positions truly below maintenance can be liquidated (to avoid being sniped when just on edge). Possibly require HF < 1 (100%) or HF < 1.05 (to include bonus) to initiate.
We ensure atomicity or proper ordering: e.g., require that the liquidator’s payment is received before transferring out collateral. In Soroban, in the liquidate function, we will call token.transfer(liquidator, contract, repay_amount) to pull the funds from liquidator (they must pre-authorize this transfer), then call lending.repay, then call token.transfer(contract, liquidator, collateral_amount). If any of these steps fail (e.g. liquidator doesn’t actually have the funds or price changed drastically making check fail), the whole call aborts and no transfer happens.
The liquidator must require_auth for the transfer of their funds too. This is another use of Soroban auth: the liquidator’s Address will have to sign for transferring, say, XLM from them to contract if short, or USDC from them to contract if long. We can enforce that in the contract call or simply the transaction structure (they can attach a Payment op but easier is just to require_auth and do transfer inside).
Slippage/Price risk for liquidator: The liquidator in our design is effectively trading at the oracle price (which is typically a few seconds TWAP). If the market is tanking rapidly, by the time they receive XLM and try to sell it, the price might be lower than they expected, potentially wiping the 5% bonus. This is their risk and typically they manage it by perhaps hedging or by only liquidating when bonus > expected slippage. It’s outside the contract’s scope but worth noting.
Pause/Disable Liquidations: In extreme conditions (oracle failure or huge volatility), an admin might pause new positions or even pause liquidations to prevent cascading. Our admin pause function could freeze open/increase and perhaps allow only reduce/close to let users de-lever. Liquidation by third-parties could also be temporarily disabled if absolutely needed by requiring an extra condition (not recommended generally, but admin could set maintenance margin so low that liquidations don’t trigger until resumed). Such measures are last-resort and would be communicated.
Overall, the liquidation logic is aligned with Soroban’s transaction model and ensures the protocol remains solvent. Liquidators have clear rules and incentives, and the system leverages both on-chain (oracle triggers) and off-chain (bots) mechanisms to reliably execute liquidations. By using an oracle-driven price
, we detach liquidation from DEX liquidity at that instant, which is important during crashes (the DEX might thin out, but oracle aggregates multiple sources and possibly even centralized exchanges if Reflector integrates them). This reduces the chance of not finding a buyer – the buyer (liquidator) is always there if the bonus is sufficient.
Security and Upgradeability Considerations
Designing a financial smart contract requires rigorous attention to security and future-proofing: Authorization and Access Control:
All sensitive operations enforce the proper authorization:
Users must authorize any transfer of their assets into or out of the contract. We use Address.require_auth() on the user for deposits, withdrawals, and position actions where the user’s funds are moved
. This prevents someone else from trying to deposit or withdraw on another’s behalf maliciously.
The margin contract interacts with token contracts (SAC/SEP-41 tokens) for transfers. These token contracts themselves require either the user’s signature or a prior allowance. In our flows, we typically rely on direct transfer(&user, &contract, amount) which, by SEP-41, will internally require the user’s auth (and we call require_auth before it to tie the signature to our call context)
. This double-check ensures the user explicitly approves the exact operation.
Liquidation calls require the liquidator to authorize spending their tokens to pay the debt. The contract might call transfer(&liquidator, &contract, repay_amount) which will only succeed if the liquidator signed. Thus, no one can be forced to pay someone’s debt; it’s a voluntary (profitable) action.
Admin-only functions (like changing risk params or upgrading contract) use an AdminAddress stored on contract deployment. We call admin_addr.require_auth() inside those functions to ensure only the admin can execute them. We might also implement a multi-sig or timelock off-chain for calling these, but that’s outside contract (the contract just sees one authorized Address which could be a multi-sig account).
No function allows arbitrary third-party fund movement. For example, there’s no method for a user to directly transfer another user’s collateral. Everything is scoped per user or per position with checks.
Reentrancy and Transaction Order:
Soroban contracts operate per transaction atomic, and there’s no concept of async callbacks as in Ethereum, so classical reentrancy is less of an issue. Each external call (like to the token contract or lending contract) executes and returns control to our contract, and we cannot be called back by them in the middle. So reentrancy attacks are largely not possible in Soroban’s model (there’s no fallback payable function to hijack). Nonetheless, we ensure state updates happen after external calls appropriately. For instance, when closing a position, we would ideally remove the position after the swap and repay succeed, not before, to avoid a half-closed position if something fails mid-transaction (though mid-transaction failure would revert anyway). We also mark positions as liquidating or closed to prevent double-liquidation on the same position by two different actors at once (though Soroban transactions are processed sequentially, and we could lock by a boolean if needed). Integer Math and Precision:
All financial calculations use fixed-point integers. We carefully manage decimal scaling:
Asset amounts (XLM, USD token) come typically as integers with their own decimals (e.g. USDC might be 7 decimal places on Stellar, XLM is 7 decimal on Stellar network as well). The oracle likely uses 7 decimals for price. We ensure to scale values up or down to a common precision when computing ratios to avoid truncation errors.
We will use Soroban SDK’s checked math or at least ensure no overflow. Using i128 for balances and prices gives a huge range (which is fine: 2^127 is enormous relative to any currency). We also guard against multiplication overflow: e.g. when computing collateral_value = price * amount, if both are i128 near max, that could overflow i128. But realistically, amounts and prices will be nowhere near that (if using 7 decimals, an amount could be up to 1e18 (10^18) for e.g. 10^11 tokens with decimals, and price up to maybe 10^7 for millions, product 10^25 which is within 2^127 ~ 10^38). We are safe, but we can use checked multiply just in case.
We consider rounding. For instance, if after partial liquidation a tiny debt remains (due to rounding down the repay), we might forgive a few smallest units to fully close. Or require the last liquidation call to cover at least the minimum units.
Oracle Security:
We trust Reflector but also design with the possibility of fallback:
If the oracle feed fails (no new prices coming), the margin contract could be stuck with stale prices. This is dangerous (no accurate HF). In such a scenario, an admin could pause new trades and perhaps increase maintenance margin to give more buffer, but ultimately, if prices move without updates, liquidations won’t trigger. This is an external dependency risk.
We mitigate by using a well-supported oracle and possibly having an emergency switch to a backup oracle or manual price input. For example, admin could call set_price_for_liquidation(asset, price) in extreme emergency (centralized intervention) – but that’s generally not desired. At least on testnet, it might be acceptable as a safety.
We also ensure the oracle contract address cannot be arbitrarily changed by anyone except admin (to prevent someone swapping in a fake oracle).
The margin contract only reads the oracle; if the oracle were malicious it could feed wrong data. There’s no direct damage except wrong liquidations. We rely on Reflector’s decentralization to prevent that.
Validation of Inputs:
All external-facing methods validate parameters:
Reject zero or obviously erroneous values (e.g. opening position with 0 size, withdrawing negative amount).
Check that any position_id provided actually exists and belongs to the caller (we’ll likely derive user from env.invoker or require user param = invoker in calls).
For withdraw, ensure asset matches one of allowed collaterals and amount <= available.
For open_position, ensure 1× <= leverage <= 5× (or leverage param is given in some scaled form and we cap it).
For close_position, ensure position is open and not already closing.
For liquidate, ensure position is liquidatable: either HF < threshold or position flagged by contract as in default. If someone tries to liquidate a healthy position, the contract will see HF >= threshold and throw an error, so it can’t be griefed.
Also, in liquidate, verify the liquidator isn’t trying to repay more than the outstanding debt.
Economic Tests:
We will simulate a variety of scenarios to test the logic (though on testnet we’ll be doing this with small amounts anyway):
Normal open -> price up -> user closes for profit (should get profit out).
Price down -> user adds collateral to avoid liquidation (should succeed if done before crossing threshold).
Price down -> liquidation triggers correctly, user ends with nothing or little, liquidator profits, lending pool fully repaid.
Multi-position scenario (if implemented): e.g. one pos gains, another loses – ensure system doesn’t liquidate if net is okay.
Interest accumulation pushing someone into liquidation.
Upgradeability:
We design the contract to be upgradeable in the future using Soroban’s built-in upgrade mechanism (if explicitly enabled). By default, Soroban contracts are mutable if you include an upgrade function. We will incorporate OpenZeppelin’s Upgradeable trait for Soroban
:
The contract will have a method like upgrade(new_wasm_hash) which only admin can call. This uses the host function to replace the WASM code (per SEP-49 standard). We ensure to restrict this to admin and to follow the storage compatibility rules.
We separate logic and data concerns to ease upgrades: e.g. store all state in simple types (maps, ints) that a new version can interpret. If a big change is needed (like adding multi-asset cross margin), we could deploy a new version and migrate data. We might use a two-step upgrade: one to update code, another to migrate storage if needed (OpenZeppelin’s UpgradeableMigratable assists with structured migrations
).
The presence of upgradeability means users must have some trust in the admin not to rug or drastically change logic. On testnet, that’s fine. By mainnet launch, ideally this would be under governance or timelocked multi-sig. But from a technical perspective, the contract will be explicitly upgradeable.
If we chose to make it immutable, we’d simply not include an upgrade function. However, given Soroban and Peridot are evolving, upgradeability is valuable for now.
We will also implement a pause() which sets a boolean flag in storage (Paused = true). Key user functions will check this and refuse to operate if paused (except maybe withdrawals and liquidations might still be allowed, depending on the emergency policy). This is a standard circuit breaker to handle unexpected bugs or oracle failures.
Possibly implement a set_emergency_liquidator(addr) that allows an address to liquidate positions regardless of HF (to handle edge cases manually). But this might not be necessary.
Testing on Soroban Testnet:
Since the target is the current Soroban testnet, we’ll deploy and test with various accounts. The design leverages only features that exist on testnet (token contracts, cross-contract calls, etc.). Path payments do work in testnet if there are offers (we’ll ensure an XLM/USDC orderbook is populated for testing). We’ll monitor events and states via the Soroban RPC to verify correct behavior. Any findings will inform tweaking parameters (like maybe set maintenance margin a bit higher if needed). External Audits and Reviews:
We would subject this design to an audit focusing on:
Ensuring no scenario where someone can withdraw more collateral than they should (especially after partially closing or during concurrent operations).
Ensuring liquidator can’t steal more collateral than the formula allows.
Ensuring no overflow or underflow (Soroban i128 will panic on underflow, which would revert tx, so safe but we avoid triggering it).
Checking that interactions with lending contract and token contracts respect their invariants (e.g. after our operations, the sum of deposits and debts in lending still line up).
Race conditions: e.g., two users trying to liquidate the same position. Only one should succeed, the other should fail gracefully (because position would be gone or HF updated by first).
That our usage of the Reflector oracle is correct (e.g. calling lastprice gives the latest price at the time of transaction execution, which is what we want).
Summary:
This technical architecture emphasizes safety at every step:
Using cross-margin to allow flexibility but carefully tracking total risk
.
Relying on proven constructs (lending pool, price oracle, Stellar DEX for liquidity).
Providing clear events and state so that off-chain monitoring (by Peridot and users) can always verify the system’s status.
Incorporating incentive alignment (liquidator profit, user interest on collateral, etc.) to encourage desirable behavior (fast liquidation, users adding collateral when needed, etc.).
And ensuring we have admin tools to respond to unforeseen issues given Soroban is new and under active development.
By following Soroban development best practices and rigorous testing, this margin trading module can be built securely on top of Peridot’s lending contracts, delivering leveraged trading functionality while safeguarding the protocol and its users.